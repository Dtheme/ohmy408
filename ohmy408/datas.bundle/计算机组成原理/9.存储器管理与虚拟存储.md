# 9 存储器管理与虚拟存储

## 导航目录

1. [虚拟存储器基本概念](#1-虚拟存储器基本概念)
2. [地址翻译与映射机制](#2-地址翻译与映射机制)
3. [页面替换算法](#3-页面替换算法)
4. [TLB与地址翻译加速](#4-tlb与地址翻译加速)
5. [段式与段页式管理](#5-段式与段页式管理)
6. [虚拟存储器性能优化](#6-虚拟存储器性能优化)
7. [技术应用总结](#7-技术应用总结)
 
## 1. 虚拟存储器基本概念

### 1.1 虚拟存储器的引入

#### 传统物理内存管理的局限性

在早期计算机系统中，程序直接使用**物理地址**访问内存，存在以下问题：

1. **内存利用率低**: 整个程序必须全部装入内存才能运行
2. **地址冲突**: 多个程序使用相同的物理地址会发生冲突
3. **内存保护困难**: 程序可能误访问其他程序的内存区域
4. **程序大小限制**: 程序大小不能超过物理内存容量

#### 虚拟存储器的解决方案

> **虚拟存储器定义**
>
> 虚拟存储器是一种存储器管理技术，它为每个进程提供一个独立的、连续的**虚拟地址空间**，通过**地址映射机制**将虚拟地址转换为物理地址，实现程序的**按需调页**和**内存保护**。

### 1.2 虚拟存储器的基本原理

#### 地址空间概念

**虚拟地址空间**: 程序使用的地址空间，对程序透明
**物理地址空间**: 实际内存的地址空间，由硬件管理

#### 工作原理示意

```
程序生成虚拟地址 → 地址翻译单元(MMU) → 物理地址 → 访问物理内存
```

#### 核心机制

1. **分页机制**: 将虚拟地址空间和物理地址空间分成固定大小的页面
2. **页表映射**: 建立虚拟页号到物理页号的映射关系
3. **按需调页**: 仅在需要时将页面从外存调入内存
4. **页面替换**: 内存满时选择合适的页面换出到外存

### 1.3 虚拟存储器的优势

| 优势 | 说明 | 技术价值 |
| :--- | :--- | :--- |
| **内存扩展** | 虚拟地址空间可大于物理内存 | 核心技术 |
| **地址保护** | 每个进程有独立的地址空间 | 安全基础 |
| **内存共享** | 多个进程可共享同一物理页面 | 效率优化 |
| **程序重定位** | 程序可加载到内存的任意位置 | 灵活性提升 |

---

## 2. 地址翻译与映射机制

### 2.1 分页式虚拟存储器

#### 基本概念

> **页面(Page)**: 虚拟地址空间的固定大小分割单位
> **页框(Page Frame)**: 物理地址空间的固定大小分割单位  
> **页表(Page Table)**: 记录虚拟页号到物理页框号映射关系的数据结构

#### 虚拟地址结构

对于一个典型的32位系统，页面大小为4KB（$2^{12}$ 字节），其虚拟地址结构如下：

```
  31                   12 11                    0
┌───────────────────────┬───────────────────────┐
│     虚拟页号 (20位)     │      页内偏移 (12位)      │
└───────────────────────┴───────────────────────┘
```
- **虚拟页号**: 标识虚拟页面，共$2^{20}$ 个页面，用于在页表中查找。
- **页内偏移**: 页面内的字节偏移，直接用作物理地址的偏移。

#### 地址翻译过程

1. **提取虚拟页号**: 从虚拟地址中提取高位作为虚拟页号
2. **查找页表**: 以虚拟页号为索引查找页表项
3. **检查有效位**: 判断页面是否在内存中
4. **组合物理地址**: 物理页框号 + 页内偏移 = 物理地址

#### 技术应用实例

**实例1**: 某32位系统采用分页式虚拟存储器，页面大小为4KB，虚拟地址0x12345678对应的虚拟页号和页内偏移分别是多少？

**解答**:
- 页面大小 = 4KB = 2^12 字节，页内偏移需要12位
- 虚拟地址 = 0x12345678 = 0001 0010 0011 0100 0101 0110 0111 1000
- 虚拟页号 = 高20位 = 0x12345 (十进制: 74565)
- 页内偏移 = 低12位 = 0x678 (十进制: 1656)

### 2.2 页表结构与组织

#### 页表项结构

一个典型的32位页表项（PTE）包含以下关键字段：
```
┌──────────────┬───┬───┬───┬───────┬───────────┐
│ 物理页框号   │ V │ M │ R │  保护 │ OS保留/其他 │
│    (20位)    │(1)│(1)│(1)│ (3位) │   (6位)   │
└──────────────┴───┴───┴───┴───────┴───────────┘
```
- **物理页框号 (Physical Page Frame Number)**: 指向物理内存中的页框（页帧）。
- **有效位 (Valid Bit, V)**: 标志该页面是否存在于物理内存中。`1`表示在内存中，`0`表示不在（产生缺页中断）。
- **修改位 (Modified Bit, M)**: 标志该页面是否被修改过。
- **引用位 (Reference Bit, R)**: 标志该页面是否被访问过。
- **保护位**: 读写执行权限控制。

#### 多级页表

为了减少页表占用的内存空间，现代系统通常采用**多级页表**：

**二级页表示例**:
```
  31              22 21              12 11                    0
┌──────────────────┬──────────────────┬───────────────────────┐
│ 一级页表索引(10位) │ 二级页表索引(10位) │      页内偏移 (12位)      │
└──────────────────┴──────────────────┴───────────────────────┘
```

**地址翻译过程**:
1. 用一级页表索引查找一级页表，得到二级页表的基址。
2. 用二级页表索引查找二级页表，得到物理页框号
3. 组合物理地址：物理页框号 + 页内偏移

### 2.3 地址翻译硬件支持

#### 内存管理单元(MMU)

> **MMU(Memory Management Unit)**: 负责虚拟地址到物理地址翻译的硬件单元，通常集成在CPU中。

**MMU的主要功能**:
- 地址翻译
- 访问权限检查  
- TLB管理
- 缺页中断处理

#### 页表寄存器

- **页表基址寄存器(PTBR)**: 存储当前进程页表的起始地址
- **页表长度寄存器(PTLR)**: 存储页表的长度，用于边界检查

---

## 3. 页面替换算法

### 3.1 页面替换的必要性

当发生**缺页中断**时，如果物理内存已满，系统必须选择一个页面换出到外存，为新页面腾出空间。**页面替换算法**决定了选择哪个页面换出。

### 3.2 最佳替换算法(OPT)

#### 算法原理

> **最佳替换算法**: 选择**未来最长时间内不会被访问**的页面进行替换。

#### 算法特点
- **理论最优**: 产生最少的缺页次数
- **实际不可实现**: 无法预知未来的访问序列
- **性能基准**: 用于评估其他算法的性能

#### 技术应用实例

**实例2**: 系统有3个页框，页面访问序列为：1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5，使用OPT算法计算缺页次数。

**解答**:

| 步骤 | 访问页面 | 页框状态 | 是否缺页 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 1 | [1, -, -] | 是 | 首次访问 |
| 2 | 2 | [1, 2, -] | 是 | 首次访问 |
| 3 | 3 | [1, 2, 3] | 是 | 首次访问 |
| 4 | 4 | [4, 2, 3] | 是 | 替换页面1(下次访问在第5步) |
| 5 | 1 | [1, 2, 3] | 是 | 替换页面4(下次访问在第11步) |
| 6 | 2 | [1, 2, 3] | 否 | 命中 |
| 7 | 5 | [1, 2, 5] | 是 | 替换页面3(下次访问在第10步) |
| 8 | 1 | [1, 2, 5] | 否 | 命中 |
| 9 | 2 | [1, 2, 5] | 否 | 命中 |
| 10 | 3 | [1, 3, 5] | 是 | 替换页面2(下次不再访问) |
| 11 | 4 | [4, 3, 5] | 是 | 替换页面1(下次不再访问) |
| 12 | 5 | [4, 3, 5] | 否 | 命中 |

**缺页次数**: 8次

### 3.3 先进先出算法(FIFO)

#### 算法原理

> **FIFO算法**: 选择**最早进入内存**的页面进行替换。

#### 实现方式
- 维护一个页面队列
- 新页面从队尾进入
- 替换时从队头选择页面

#### Belady异常

FIFO算法存在**Belady异常**: 增加页框数量可能导致缺页次数增加。

#### 技术应用实例

**实例3**: 使用与实例2相同的访问序列，采用FIFO算法计算缺页次数。

**解答**:

| 步骤 | 访问页面 | 页框状态 | 是否缺页 | FIFO队列 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 1 | [1, -, -] | 是 | [1] |
| 2 | 2 | [1, 2, -] | 是 | [1, 2] |
| 3 | 3 | [1, 2, 3] | 是 | [1, 2, 3] |
| 4 | 4 | [4, 2, 3] | 是 | [2, 3, 4] |
| 5 | 1 | [4, 1, 3] | 是 | [3, 4, 1] |
| 6 | 2 | [4, 1, 2] | 是 | [4, 1, 2] |
| 7 | 5 | [5, 1, 2] | 是 | [1, 2, 5] |
| 8 | 1 | [5, 1, 2] | 否 | [1, 2, 5] |
| 9 | 2 | [5, 1, 2] | 否 | [1, 2, 5] |
| 10 | 3 | [3, 1, 2] | 是 | [2, 5, 3] |
| 11 | 4 | [3, 4, 2] | 是 | [5, 3, 4] |
| 12 | 5 | [3, 4, 5] | 是 | [3, 4, 5] |

**缺页次数**: 10次

### 3.4 最近最少使用算法(LRU)

#### 算法原理

> **LRU算法**: 选择**最近最长时间未被访问**的页面进行替换。

#### 实现方式

**1. 链表实现**:
- 维护一个按访问时间排序的链表
- 最近访问的页面移到链表头部
- 替换时选择链表尾部的页面

**2. 计数器实现**:
- 为每个页面设置访问时间计数器
- 每次访问时更新计数器
- 替换时选择计数器值最小的页面

#### 技术应用实例

**实例4**: 使用与实例2相同的访问序列，采用LRU算法计算缺页次数。

**解答**:

| 步骤 | 访问页面 | 页框状态 | 是否缺页 | LRU顺序(最近→最远) |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 1 | [1, -, -] | 是 | [1] |
| 2 | 2 | [1, 2, -] | 是 | [2, 1] |
| 3 | 3 | [1, 2, 3] | 是 | [3, 2, 1] |
| 4 | 4 | [4, 2, 3] | 是 | [4, 3, 2] (替换最远的1) |
| 5 | 1 | [4, 1, 3] | 是 | [1, 4, 3] (替换最远的2) |
| 6 | 2 | [2, 1, 3] | 是 | [2, 1, 4] (替换最远的3) |
| 7 | 5 | [2, 1, 5] | 是 | [5, 2, 1] (替换最远的4) |
| 8 | 1 | [2, 1, 5] | 否 | [1, 5, 2] |
| 9 | 2 | [2, 1, 5] | 否 | [2, 1, 5] |
| 10 | 3 | [2, 3, 5] | 是 | [3, 2, 1] (替换最远的1) |
| 11 | 4 | [4, 3, 5] | 是 | [4, 3, 2] (替换最远的2) |
| 12 | 5 | [4, 3, 5] | 否 | [5, 4, 3] |

**缺页次数**: 9次

### 3.5 时钟算法(Clock)

#### 算法原理

> **时钟算法**: LRU算法的近似实现，使用**引用位**记录页面访问情况，采用循环扫描方式选择替换页面。

#### 实现步骤

1. **初始化**: 所有页面的引用位设为0，指针指向任意页面
2. **页面访问**: 将被访问页面的引用位设为1
3. **页面替换**:
   - 从当前指针位置开始扫描
   - 如果引用位为0，选择该页面替换
   - 如果引用位为1，将其设为0，继续扫描下一个

#### 改进版本

**改进时钟算法**: 同时考虑引用位(R)和修改位(M)

| R | M | 页面类别 | 替换优先级 |
| :-- | :-- | :--- | :--- |
| 0 | 0 | 未引用且未修改 | 最高(1) |
| 0 | 1 | 未引用但已修改 | 较高(2) |
| 1 | 0 | 已引用但未修改 | 较低(3) |
| 1 | 1 | 已引用且已修改 | 最低(4) |

---

## 4. TLB与地址翻译加速

### 4.1 TLB的引入背景

#### 地址翻译的性能问题

在分页系统中，每次内存访问都需要查找页表进行地址翻译：
- **单级页表**: 需要1次额外的内存访问
- **二级页表**: 需要2次额外的内存访问  
- **三级页表**: 需要3次额外的内存访问

这大大降低了系统性能。

#### TLB的解决方案

> **TLB(Translation Lookaside Buffer)**: 页表的高速缓存，存储最近使用的页表项，加速地址翻译过程。

### 4.2 TLB的工作原理

#### TLB结构

TLB是一个全相联或组相联的高速缓存，每个TLB项包含：

| 字段 | 说明 |
| :--- | :--- |
| **虚拟页号** | 用于匹配查找 |
| **物理页框号** | 翻译结果 |
| **有效位** | TLB项是否有效 |
| **保护位** | 访问权限信息 |
| **脏位** | 是否被修改 |

#### 带TLB的地址翻译过程

1. **TLB查找**: 用虚拟页号在TLB中查找
2. **TLB命中**: 直接获得物理页框号，组合物理地址
3. **TLB未命中**: 查找页表获得翻译结果，更新TLB

#### 技术应用实例

**实例5**: 某系统TLB命中率为95%，TLB访问时间为1ns，内存访问时间为100ns，页表为单级。计算平均地址翻译时间。

**解答**:
- TLB命中时：翻译时间 = 1ns
- TLB未命中时：翻译时间 = 1ns(TLB) + 100ns(页表) = 101ns
- 平均翻译时间 = 0.95 × 1 + 0.05 × 101 = 0.95 + 5.05 = 6ns

### 4.3 TLB管理策略

#### TLB替换算法

与缓存类似，TLB也需要替换算法：
- **LRU**: 最近最少使用
- **FIFO**: 先进先出  
- **随机**: 随机选择

#### TLB一致性维护

当页表内容发生变化时，需要保证TLB的一致性：
- **页面换出**: 无效化对应的TLB项
- **页表修改**: 刷新相关的TLB项
- **进程切换**: 刷新整个TLB或使用进程标识符

---

## 5. 段式与段页式管理

### 5.1 段式存储管理

#### 基本概念

> **段式存储管理**: 按照程序的逻辑结构将虚拟地址空间分成若干个**段**，每个段有独立的名称和长度。

#### 段的特点

- **变长**: 段的长度可以不同
- **逻辑性**: 反映程序的逻辑结构
- **保护性**: 可对不同段设置不同的访问权限

#### 虚拟地址结构

```
┌───────────┬──────────────┐
│   段号    │   段内偏移   │
└───────────┴──────────────┘
```

#### 段表结构

| 字段 | 说明 |
| :--- | :--- |
| **段基址** | 段在物理内存中的起始地址 |
| **段长度** | 段的长度 |
| **保护位** | 访问权限控制 |

### 5.2 段页式存储管理

#### 基本思想

> **段页式存储管理**: 结合段式和页式管理的优点，先将虚拟地址空间分段，再将每个段分页。

#### 虚拟地址结构

```
  31      24 23          12 11                    0
┌──────────┬───────────────┬───────────────────────┐
│ 段号(8位)│ 段内页号(12位)  │      页内偏移 (12位)      │
└──────────┴───────────────┴───────────────────────┘
```

#### 地址翻译过程

1. **段表查找**: 用段号查找段表，获得该段的页表基址
2. **页表查找**: 用段内页号查找页表，获得物理页框号  
3. **组合地址**: 物理页框号 + 页内偏移 = 物理地址

#### 技术应用实例

**实例6**: 某段页式系统中，虚拟地址为32位，段号8位，段内页号12位，页内偏移12位。虚拟地址0x23456789的段号、段内页号和页内偏移分别是什么？

**解答**:
- 虚拟地址 = 0x23456789 = 0010 0011 0100 0101 0110 0111 1000 1001
- 段号 = 高8位 = 0x23 = 35
- 段内页号 = 中间12位 = 0x456 = 1110  
- 页内偏移 = 低12位 = 0x789 = 1929

#### 主要性能指标

| 指标 | 定义 | 计算公式 |
| :--- | :--- | :--- |
| **缺页率** | 缺页次数与总访问次数的比值 | 缺页率 = 缺页次数 / 总访问次数 |
| **平均访问时间** | 考虑缺页处理的平均访问时间 | EAT = (1-p)×ma + p×缺页处理时间 |
| **有效访问时间** | 实际的平均访问时间 | 包含TLB、缓存等各级延迟 |

其中：p为缺页率，ma为内存访问时间

#### 技术应用实例

**实例7**: 某系统缺页率为0.01，内存访问时间为100ns，缺页处理时间(包括页面调入)为10ms。计算平均访问时间。

**解答**:
- p = 0.01, ma = 100ns = 0.1μs, 缺页处理时间 = 10ms = 10000μs
- EAT = (1-0.01) × 0.1 + 0.01 × 10000 = 0.099 + 100 = 100.099μs

### 6.2 优化策略

#### 1. 减少缺页率

- **程序局部性优化**: 提高程序的时间局部性和空间局部性
- **预取技术**: 预先调入可能访问的页面
- **工作集管理**: 维持进程的工作集在内存中

#### 2. 提高地址翻译速度

- **增大TLB**: 提高TLB命中率
- **优化页表结构**: 采用多级页表减少页表大小
- **硬件支持**: 专门的地址翻译硬件

#### 3. 减少页面调度开销

- **批量调页**: 一次调入多个连续页面
- **智能替换**: 采用更好的页面替换算法
- **写优化**: 减少写操作的页面调度

---

## 7. 技术应用总结

### 6.3 页面替换算法对比表

| 算法 | 选择策略 | 实现复杂度 | 性能表现 | 是否最优 | 典型应用 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **OPT** | 选择未来最长时间不用的页面 | 不可实现 | 理论最优 | 是 | 性能基准 |
| **FIFO** | 选择最早进入的页面 | 简单 | 一般 | 否 | 简单系统 |
| **LRU** | 选择最长时间未访问的页面 | 复杂 | 较好 | 否 | 现代系统 |
| **LFU** | 选择访问频率最低的页面 | 复杂 | 较好 | 否 | 特殊应用 |
| **时钟算法** | 近似LRU，使用引用位 | 中等 | 良好 | 否 | 实际系统 |
| **改进时钟** | 考虑引用位和修改位 | 中等 | 很好 | 否 | 高性能系统 |

### 7.1 核心技术点

#### 1. 虚拟存储器概念

**技术特点**: 基础理论概念
**核心内容**:
- 虚拟存储器的定义和作用
- 虚拟地址空间与物理地址空间的关系
- 分页机制的基本原理

**工程应用**:
- 虚拟存储器与传统存储器管理的区别
- 分页机制的优势和特点
- 虚拟地址到物理地址的翻译过程

#### 2. 地址翻译机制

**技术特点**: 核心实现技术
**核心内容**:
- 虚拟地址结构的划分
- 页表的组织和查找
- 多级页表的地址翻译

**工程应用**:
- 给定虚拟地址求虚拟页号和页内偏移
- 页表大小和页表项数量的计算
- 多级页表的地址翻译过程

#### 3. 页面替换算法

**技术特点**: 性能优化算法
**核心内容**:
- FIFO、LRU、OPT算法的原理和实现
- 时钟算法的工作过程
- 缺页次数和命中率的计算

**工程应用**:
- 给定访问序列计算各算法的缺页次数
- 比较不同算法的性能
- Belady异常的概念和实例

### 7.2 重要计算公式

#### 地址翻译相关

```
页面大小 = 2^页内偏移位数
虚拟页号 = 虚拟地址 / 页面大小  
页内偏移 = 虚拟地址 % 页面大小
物理地址 = 物理页框号 × 页面大小 + 页内偏移
```

#### 性能计算相关

```
缺页率 = 缺页次数 / 总访问次数
命中率 = 1 - 缺页率
平均访问时间 = (1-缺页率) × 内存访问时间 + 缺页率 × 缺页处理时间
```

#### TLB性能计算

```
TLB平均查找时间 = TLB命中率 × TLB访问时间 + TLB未命中率 × (TLB访问时间 + 页表访问时间)
```

### 7.3 常见易错点

#### 1. 地址计算错误

- **混淆虚拟地址和物理地址**: 注意区分地址翻译的输入和输出
- **页面大小单位错误**: 注意KB和B的换算关系
- **位数计算错误**: 页内偏移位数 = log₂(页面大小)

#### 2. 页面替换算法理解错误

- **FIFO与LRU混淆**: FIFO关注进入时间，LRU关注访问时间
- **时钟算法扫描方向**: 通常是顺时针扫描
- **引用位更新时机**: 页面被访问时立即更新

#### 3. 性能计算错误

- **时间单位不统一**: 注意ns、μs、ms的换算
- **缺页处理时间遗漏**: 包含页面调入、更新页表等时间
- **TLB访问时间计算**: 区分命中和未命中的情况
