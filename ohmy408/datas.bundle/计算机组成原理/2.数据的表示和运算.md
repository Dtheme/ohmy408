# 2 数据的表示和运算

## 导航目录

1. [数制与编码](#1-数制与编码)
2. [定点数的表示和运算](#2-定点数的表示和运算)
3. [浮点数的表示和运算](#3-浮点数的表示和运算)
4. [算术逻辑单元ALU](#4-算术逻辑单元alu)
5. [典型例题](#5-典型例题)
 

## 1. 数制与编码

### 1.1 数制转换

#### 1.1.1 各种数制的基本概念

**定义1.1（r进制数）**

设r为正整数且r≥2，任意一个数N都可以表示为：
$$N = a_n \cdot r^n + a_{n-1} \cdot r^{n-1} + \cdots + a_1 \cdot r^1 + a_0 \cdot r^0 + a_{-1} \cdot r^{-1} + \cdots$$
其中，$0 \leq a_i < r$ ，r称为基数或底数。

**常用数制**:
- **二进制**: r=2，数字符号{0,1}
- **八进制**: r=8，数字符号{0,1,2,3,4,5,6,7}  
- **十进制**: r=10，数字符号{0,1,2,3,4,5,6,7,8,9}
- **十六进制**: r=16，数字符号{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}

#### 1.1.2 数制转换方法

**十进制转r进制（整数部分）**:
- 方法: 除r取余法
- 步骤: 用r连续除被转换数，直到商为0，余数逆序排列

**十进制转r进制（小数部分）**:
- 方法: 乘r取整法  
- 步骤: 用r连续乘小数部分，直到小数部分为0或达到精度要求

> **例题1.1**：将十进制数$157.625_{10}$ 转换为二进制数。

**解析**：

整数部分157转二进制：
```
157 ÷ 2 = 78 ... 1
 78 ÷ 2 = 39 ... 0  
 39 ÷ 2 = 19 ... 1
 19 ÷ 2 = 9  ... 1
  9 ÷ 2 = 4  ... 1
  4 ÷ 2 = 2  ... 0
  2 ÷ 2 = 1  ... 0
  1 ÷ 2 = 0  ... 1

逆序排列：10011101
```

小数部分0.625转二进制：
```
0.625 × 2 = 1.25 → 取整1，余0.25
0.25  × 2 = 0.5  → 取整0，余0.5
0.5   × 2 = 1.0  → 取整1，余0

顺序排列：101
```

**答案**：$157.625_{10} = 10011101.101_2$

### 1.2 BCD码与字符编码

#### 1.2.1 BCD码

**定义1.2（BCD码）**

BCD码（Binary-Coded Decimal）是用4位二进制数来表示1位十进制数的编码方式。

**8421 BCD码编码表**：

| 十进制 | 8421 BCD码 | 十进制 | 8421 BCD码 |
|--------|------------|--------|------------|
| 0 | 0000 | 5 | 0101 |
| 1 | 0001 | 6 | 0110 |
| 2 | 0010 | 7 | 0111 |
| 3 | 0011 | 8 | 1000 |
| 4 | 0100 | 9 | 1001 |

**注意**：1010、1011、1100、1101、1110、1111在8421 BCD码中是非法组合。

#### 1.2.2 其他BCD码类型

**余3码（Excess-3 Code）**：
- 在8421 BCD码基础上加3得到
- 具有自补性质：9的余3码是0的余3码的反码
- 用于简化减法运算

| 十进制 | 8421 BCD | 余3码 |
|--------|----------|-------|
| 0 | 0000 | 0011 |
| 1 | 0001 | 0100 |
| 2 | 0010 | 0101 |
| 3 | 0011 | 0110 |
| 4 | 0100 | 0111 |
| 5 | 0101 | 1000 |
| 6 | 0110 | 1001 |
| 7 | 0111 | 1010 |
| 8 | 1000 | 1011 |
| 9 | 1001 | 1100 |

**Gray码（格雷码）**：
- 相邻两个码字只有一位不同
- 用于减少数字系统中的错误
- 广泛应用于A/D转换器

#### 1.2.3 BCD码运算

**BCD码加法运算规则**：
1. 按二进制加法规则相加
2. 如果结果 ≤ 9，则结果正确
3. 如果结果 > 9 或有进位，则加6修正

> **例题1.3**：计算BCD码加法：(0101)BCD + (0111)BCD

**解析**：
```
  0101  (5)
+ 0111  (7)
-------
  1100  (12，大于9需要修正)
+ 0110  (加6修正)
-------
 10010  (结果：1 0010，即12的BCD码)
```

> **例题1.2**：将十进制数$3954_{10}$ 转换为8421 BCD码。

**解析**：
```
3 → 0011
9 → 1001  
5 → 0101
4 → 0100

连接得：0011 1001 0101 0100
```

**答案**：$3954_{10} = 0011100101010100_{BCD}$

#### 1.2.2 字符编码

**ASCII码**：
- 7位编码，可表示128个字符
- 包括控制字符、数字、字母、特殊符号
- 数字字符'0'-'9'：30H-39H
- 大写字母'A'-'Z'：41H-5AH  
- 小写字母'a'-'z'：61H-7AH

---

## 2. 定点数的表示和运算

### 2.1 定点数的表示

#### 2.1.1 机器数与真值

> **定义2.1（机器数）**
> 
> 在计算机中，数值连同符号一起编码表示的形式称为机器数。机器数的最高位为符号位，0表示正数，1表示负数。

> **定义2.2（真值）**
> 
> 机器数所对应的实际数值称为真值。

**示例**：
- 真值：$+1011_2$ 和$-1011_2$
- 8位机器数表示：需要将符号数字化

#### 2.1.2 原码表示

> **定义2.3（原码）**
> 
> 原码是最简单的机器数表示方法，符号位用0和1表示，数值部分用绝对值的二进制表示。

**n位原码表示范围**：$-(2^{n-1}-1) \leq X \leq +(2^{n-1}-1)$

**原码表示规则**：
- 正数：符号位为0，数值部分为二进制绝对值
- 负数：符号位为1，数值部分为二进制绝对值

> **例题2.1**：用8位原码表示$+19_{10}$ 和$-19_{10}$。

**解析**：
```
+19₁₀ = +10011₂
8位原码：[+19]原 = 00010011

-19₁₀ = -10011₂  
8位原码：[-19]原 = 10010011
```

**答案**：$[+19]_{原} = 00010011$ ，$[-19]_{原} = 10010011$

#### 2.1.3 反码表示

> **定义2.4（反码）**
> 
> 正数的反码与原码相同；负数的反码是将原码除符号位外，其余各位取反。

**反码表示规则**：
- 正数：反码 = 原码
- 负数：符号位不变，数值位按位取反

> **例题2.2**：用8位反码表示$+19_{10}$ 和$-19_{10}$。

**解析**：
```
+19₁₀：[+19]反 = [+19]原 = 00010011

-19₁₀：[-19]原 = 10010011
      数值位取反：01101100
      [-19]反 = 11101100
```

**答案**：$[+19]_{反} = 00010011$ ，$[-19]_{反} = 11101100$

#### 2.1.4 补码表示

> **定义2.5（补码）**
> 
> 正数的补码与原码相同；负数的补码是将反码的最低位加1。

**n位补码表示范围**：$-2^{n-1} \leq X \leq +(2^{n-1}-1)$

**补码表示规则**：
- 正数：补码 = 原码 = 反码
- 负数：补码 = 反码 + 1

> **例题2.3**：用8位补码表示$+19_{10}$ 和$-19_{10}$。

**解析**：
```
+19₁₀：[+19]补 = [+19]原 = 00010011

-19₁₀：[-19]反 = 11101100
      加1：11101100 + 1 = 11101101
      [-19]补 = 11101101
```

**答案**：$[+19]_{补} = 00010011$ ，$[-19]_{补} = 11101101$

### 2.2 定点数的运算

#### 2.2.1 补码加法运算

> **补码加法运算规则**：
> 1. 将两个补码数（包括符号位）直接相加
> 2. 如果有进位，直接丢弃
> 3. 结果仍为补码形式

> **例题2.4**：计算$[+19]_{补} + [-19]_{补}$。

**解析**：
```
  00010011  (+19的补码)
+ 11101101  (-19的补码)
-----------
 100000000  
```
丢弃最高位进位，结果为：00000000

**答案**：结果为0的补码表示：00000000

#### 2.2.2 补码减法运算

**补码减法运算规则**：
$$[A]_{补} - [B]_{补} = [A]_{补} + [-B]_{补}$$

**求补码的负数方法**：
1. **取反加1法**：对补码按位取反后加1
2. **从右向左保留第一个1及其右边所有0，其余位取反**

> **例题2.5**：计算$[+25]_{补} - [+18]_{补}$

**解析**：
```
+25的补码：00011001
+18的补码：00010010
-18的补码：11101110（取反加1）

  00011001
+ 11101110
----------
 100000111

舍弃最高位进位，结果：00000111 = +7
验证：25 - 18 = 7 ✓
```

#### 2.2.3 溢出检测

> **定义2.6（溢出）**
> 
> 当运算结果超出机器数所能表示的范围时，称为溢出。

**溢出检测方法**：

**方法1：双符号位法**
- 用两位符号位：00表示正数，11表示负数
- 01表示正溢出，10表示负溢出

**方法2：单符号位法**
- 溢出标志：$V = C_n \oplus C_{n-1}$
-$C_n$：最高位进位，$C_{n-1}$：符号位进位
- V=1表示溢出，V=0表示无溢出

**方法3：符号检测法**
- 两个同号数相加，结果符号与操作数符号不同则溢出
- 正数 + 正数 = 负数 → 正溢出
- 负数 + 负数 = 正数 → 负溢出  
- 正数 + 负数 → 不会溢出

#### 2.2.4 定点数乘法运算

**原码一位乘法**：
1. 符号位单独处理：$S_积 = S_被乘数 \oplus S_乘数$
2. 数值部分按无符号数乘法
3. 逐位检查乘数，为1则加被乘数，为0则不加
4. 每次操作后积右移一位

**补码一位乘法（Booth算法）**：
- 根据乘数当前位和前一位的组合决定操作
- 减少加法操作次数，提高效率

**Booth算法操作表**：

| 乘数当前位  | 乘数前一位  | 操作           |
|-------------|-------------|----------------|
| 0           | 0           | 右移           |
| 0           | 1           | 加被乘数，右移 |
| 1           | 0           | 减被乘数，右移 |
| 1           | 1           | 右移           |

#### 2.2.5 定点数除法运算

**原码除法（恢复余数法）**：
1. 符号位单独处理
2. 被除数左移一位，与除数比较
3. 够减则商1，余数为减法结果
4. 不够减则商0，恢复原余数
5. 重复直到得到所需精度

**补码除法（不恢复余数法）**：
1. 符号位参与运算
2. 余数与除数同号则做减法
3. 余数与除数异号则做加法
4. 根据余数符号确定商的位值

#### 2.2.6 定点数运算的硬件实现

**加法器设计**：
- 串行进位加法器：简单但速度慢
- 并行进位加法器：速度快但硬件复杂
- 超前进位加法器：平衡速度和复杂度

**乘法器设计**：
- 串行乘法器：逐位处理，硬件简单
- 并行乘法器：同时处理多位，速度快
- 阵列乘法器：规整结构，便于VLSI实现

---

## 3. 浮点数的表示和运算

### 3.1 浮点数的表示

#### 3.1.1 单精度浮点数（32位）

**格式定义**:
```
  31   30      23 22                    0
┌───┬──────────┬───────────────────────┐
│ S │  E (8位) │       M (23位)        │
└───┴──────────┴───────────────────────┘
```
- **S (Sign)**: 1位符号位 (0为正, 1为负)
- **E (Exponent)**: 8位阶码，使用**移码**表示 (偏置值为127)
- **M (Mantissa)**: 23位尾数，表示小数部分

**数值计算**:
$$V = (-1)^S \times 1.M \times 2^{E-127}$$

#### 3.1.2 双精度浮点数（64位）

**格式定义**:
```
  63   62       52 51                   0
┌───┬────────────┬──────────────────────┐
│ S │  E (11位)  │       M (52位)       │
└───┴────────────┴──────────────────────┘
```
- **S (Sign)**: 1位符号位
- **E (Exponent)**: 11位阶码 (偏置值为1023)
- **M (Mantissa)**: 52位尾数

**数值计算**:
$$V = (-1)^S \times 1.M \times 2^{E-1023}$$

#### 3.1.3 特殊值表示

**IEEE 754标准定义了一些特殊值**：

### 3.2 浮点数运算

#### 3.2.1 浮点数加减运算

**浮点数加减运算步骤**：
1. **零操作数检查**：若有操作数为0，结果为另一操作数
2. **指数对齐**：将小指数的尾数右移，使两数指数相等
3. **尾数运算**：对对齐后的尾数进行加减运算
4. **规格化**：调整结果使其符合规格化要求
5. **舍入处理**：根据舍入规则处理多余位
6. **溢出检查**：检查指数是否溢出

> **例题3.2**：计算两个规格化浮点数的加法（设指数8位，尾数8位，偏置值127）。
> 
>$X = 0,10000010,10110000$
>$Y = 0,10000000,10010000$

**解析**：

1. **分析操作数**：
   ```
   X: 指数130，尾数1.10110000
   Y: 指数128，尾数1.10010000
   ```

2. **指数对齐**：
   ```
   指数差 = 130 - 128 = 2
   Y的尾数右移2位：1.10010000 → 0.01100100
   ```

3. **尾数相加**：
   ```
     1.10110000
   + 0.01100100
   ------------
     10.00010100
   ```

4. **规格化**：
   ```
   10.00010100 → 1.000010100 × 2¹
   新指数 = 130 + 1 = 131
   ```

**答案**：结果为$0,10000011,00001010$

---

## 4. 算术逻辑单元ALU

### 4.1 ALU的基本概念

#### 4.1.1 ALU的功能和结构

> **定义4.1（算术逻辑单元ALU）**
> 
> ALU是CPU中专门执行算术运算和逻辑运算的硬件单元，是计算机的核心运算部件。

**ALU的基本功能**:
- **算术运算**: 加、减、乘、除
- **逻辑运算**: 与、或、非、异或  
- **比较运算**: 大于、小于、等于
- **移位运算**: 左移、右移

**ALU的输入输出**:
- **输入**: 两个操作数A、B，操作控制信号
- **输出**: 运算结果F，状态标志位

#### 4.1.2 状态标志位

**常见状态标志位**:
- **CF（进位标志）**: 运算产生进位时置1
- **ZF（零标志）**: 运算结果为零时置1
- **SF（符号标志）**: 运算结果为负时置1
- **OF（溢出标志）**: 运算发生溢出时置1

### 4.2 加法器的设计

#### 4.2.1 半加器和全加器

> **定义4.2（半加器）**
> 
> 半加器能够实现两个1位二进制数的加法运算，产生和位S和进位位C。

**半加器真值表**：

| A   | B   | S   | C   |
|-----|-----|-----|-----|
| 0   | 0   | 0   | 0   |
| 0   | 1   | 1   | 0   |
| 1   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   |

**逻辑表达式**：
-$S = A \oplus B$ （异或）
-$C = A \cdot B$ （与）

> **定义4.3（全加器）**
> 
> 全加器能够实现两个1位二进制数及低位进位的加法运算。

**全加器真值表**：

| A   | B   | Ci   | S    | Co   |
|-----|-----|------|------|------|
| 0   | 0   | 0    | 0    | 0    |
| 0   | 0   | 1    | 1    | 0    |
| 0   | 1   | 0    | 1    | 0    |
| 0   | 1   | 1    | 0    | 1    |
| 1   | 0   | 0    | 1    | 0    |
| 1   | 0   | 1    | 0    | 1    |
| 1   | 1   | 0    | 0    | 1    |
| 1   | 1   | 1    | 1    | 1    |

**逻辑表达式**：
-$S = A \oplus B \oplus Ci$
-$Co = AB + (A \oplus B)Ci$

#### 4.2.2 串行进位加法器

**串行进位加法器结构**：
- 由n个全加器级联组成
- 低位的进位输出连接到高位的进位输入
- 进位信号串行传播

**优缺点**:
- **优点**: 结构简单，硬件开销小
- **缺点**: 进位传播延迟大，运算速度慢

---

## 5. 典型例题与解析

### 例题1：数制转换综合

**题目**：完成下列数制转换：
1.$(1101.11)_2 = ()_{10}$
2.$(89.375)_{10} = ()_2$  
3.$(2BC.4)_{16} = ()_{10}$

**解析**：

1. **二进制转十进制**：
   ```
   (1101.11)₂ = 1×2³ + 1×2² + 0×2¹ + 1×2⁰ + 1×2⁻¹ + 1×2⁻²
              = 8 + 4 + 0 + 1 + 0.5 + 0.25
              = 13.75₁₀
   ```

2. **十进制转二进制**：
   ```
   整数部分89：
   89÷2=44...1, 44÷2=22...0, 22÷2=11...0, 11÷2=5...1
   5÷2=2...1, 2÷2=1...0, 1÷2=0...1
   整数部分：1011001₂
   
   小数部分0.375：
   0.375×2=0.75→0, 0.75×2=1.5→1, 0.5×2=1.0→1
   小数部分：011₂
   
   结果：1011001.011₂
   ```

3. **十六进制转十进制**：
   ```
   (2BC.4)₁₆ = 2×16² + 11×16¹ + 12×16⁰ + 4×16⁻¹
             = 2×256 + 11×16 + 12×1 + 4×0.0625
             = 512 + 176 + 12 + 0.25
             = 700.25₁₀
   ```

**答案**：
1.$(1101.11)_2 = (13.75)_{10}$
2.$(89.375)_{10} = (1011001.011)_2$
3.$(2BC.4)_{16} = (700.25)_{10}$

### 例题2：补码运算与溢出检测

**题目**：已知$X = +1001011_2$ ，$Y = -0110110_2$ ，字长为8位，求：
1.$[X]_{补}$ 和$[Y]_{补}$
2.$[X + Y]_{补}$ 并判断是否溢出

**解析**：

1. **求补码**：
   ```
   X = +1001011₂ = +75₁₀
   [X]补 = 01001011₂
   
   Y = -0110110₂ = -54₁₀
   [Y]原 = 10110110₂
   [Y]反 = 11001001₂  
   [Y]补 = 11001010₂
   ```

2. **补码加法**：
   ```
     01001011  ([X]补)
   + 11001010  ([Y]补)
   -----------
    100010101
   ```
   
   丢弃最高位进位：00010101₂ = +21₁₀
   
   **溢出检测**：
   - 符号位进位：C7 = 1  
   - 最高数值位进位：C6 = 0
   - C7 ≠ C6，但这里是正数+负数，不会溢出
   - 实际验证：75 + (-54) = 21，在8位补码范围内

**答案**：
1.$[X]_{补} = 01001011$ ，$[Y]_{补} = 11001010$
2.$[X + Y]_{补} = 00010101$ ，无溢出

### 例题3：IEEE 754浮点数

**题目**：已知IEEE 754单精度浮点数的二进制表示为：
11000001101000000000000000000000
求该数的十进制值。

**解析**：

1. **分解各部分**：
   ```
   符号位S = 1
   指数E = 10000011₂ = 131₁₀
   尾数M = 10100000000000000000000₂
   ```

2. **计算数值**：
   ```
   实际指数 = E - 127 = 131 - 127 = 4
   完整尾数 = 1.M = 1.101₂ = 1.625₁₀
   ```

3. **最终结果**：
   ```
   N = (-1)¹ × 1.625 × 2⁴
     = -1 × 1.625 × 16
     = -26₁₀
   ```

**答案**：该IEEE 754单精度浮点数表示$-26.0$
