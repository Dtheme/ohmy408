# 1.6 éŸ³é¢‘è°ƒè¯•ä¸æ€§èƒ½åˆ†æ

## æ¦‚è¿°

éŸ³é¢‘åº”ç”¨çš„è°ƒè¯•å’Œæ€§èƒ½åˆ†ææ˜¯ç¡®ä¿ç”¨æˆ·ä½“éªŒçš„å…³é”®ç¯èŠ‚ã€‚ä¸æ™®é€šåº”ç”¨ä¸åŒï¼ŒéŸ³é¢‘åº”ç”¨å¯¹å®æ—¶æ€§ã€å†…å­˜ç®¡ç†å’ŒCPUä½¿ç”¨æœ‰æå…¶ä¸¥æ ¼çš„è¦æ±‚ã€‚æœ¬æ–‡æ¡£æä¾›ä¼ä¸šçº§éŸ³é¢‘è°ƒè¯•å’Œæ€§èƒ½åˆ†æçš„å®Œæ•´è§£å†³æ–¹æ¡ˆï¼Œæ¶µç›–ä»å¼€å‘é˜¶æ®µåˆ°ç”Ÿäº§ç¯å¢ƒçš„å…¨æµç¨‹ç›‘æ§ã€‚

### éŸ³é¢‘è°ƒè¯•çš„ç‰¹æ®ŠæŒ‘æˆ˜

```mermaid
mindmap
  root)éŸ³é¢‘è°ƒè¯•æŒ‘æˆ˜(
    å®æ—¶æ€§è¦æ±‚
      æ¯«ç§’çº§å»¶è¿Ÿ
      ç¡®å®šæ€§æ‰§è¡Œ
      ä¸­æ–­å®¹å¿åº¦ä½
      æ—¶åºæ•æ„Ÿ
    æ€§èƒ½çº¦æŸ
      CPUå¯†é›†å‹
      å†…å­˜å¸¦å®½é™åˆ¶
      ç¼“å­˜æ•æ„Ÿ
      åŠŸè€—æ§åˆ¶
    å¤šçº¿ç¨‹å¤æ‚æ€§
      å›è°ƒçº¿ç¨‹
      ä¸»çº¿ç¨‹åŒæ­¥
      ä¼˜å…ˆçº§ç®¡ç†
      æ­»é”é£é™©
    ç¡¬ä»¶ç›¸å…³
      è®¾å¤‡å·®å¼‚
      éŸ³é¢‘è·¯ç”±
      é‡‡æ ·ç‡å˜åŒ–
      æ ¼å¼æ”¯æŒ
```

## Instruments éŸ³é¢‘æ€§èƒ½åˆ†æ

### 1. Audio Performance å·¥å…·æ·±åº¦ä½¿ç”¨

```swift
// éŸ³é¢‘æ€§èƒ½åˆ†æå™¨
class AudioPerformanceAnalyzer {
    private let signposter = OSSignposter(subsystem: "com.app.audio", category: "performance")
    private let audioLog = OSLog(subsystem: "com.app.audio", category: "audio")
    
    // æ€§èƒ½æŒ‡æ ‡æ”¶é›†
    private var renderingMetrics = RenderingMetrics()
    private var memoryMetrics = MemoryMetrics()
    private var cpuMetrics = CPUMetrics()
    
    func startAnalysis() {
        setupInstrumentsIntegration()
        startMetricsCollection()
        setupPerformanceCallbacks()
    }
    
    private func setupInstrumentsIntegration() {
        // é…ç½® os_signpost ç”¨äº Instruments æ—¶é—´çº¿åˆ†æ
        os_signpost(.begin, log: audioLog, name: "AudioEngine_Initialization")
        
        // æ ‡è®°å…³é”®éŸ³é¢‘è·¯å¾„
        markAudioRenderingPath()
        markBufferManagement()
        markFormatConversion()
    }
    
    private func markAudioRenderingPath() {
        let spid = signposter.makeSignpostID()
        
        // åœ¨éŸ³é¢‘æ¸²æŸ“å›è°ƒä¸­ä½¿ç”¨
        let renderCallback: AURenderCallback = { (inRefCon, ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, ioData) in
            
            let analyzer = Unmanaged<AudioPerformanceAnalyzer>.fromOpaque(inRefCon!).takeUnretainedValue()
            
            // å¼€å§‹æ¸²æŸ“è®¡æ—¶
            analyzer.signposter.emitEvent("AudioRender_Start", id: spid)
            
            let startTime = mach_absolute_time()
            
            // æ‰§è¡ŒéŸ³é¢‘å¤„ç†
            let result = analyzer.processAudioFrame(ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, ioData)
            
            let endTime = mach_absolute_time()
            let duration = endTime - startTime
            
            // ç»“æŸæ¸²æŸ“è®¡æ—¶
            analyzer.signposter.emitEvent("AudioRender_End", id: spid, "Duration: %{public}llu", duration)
            
            // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
            analyzer.collectRenderingMetrics(duration: duration, frameCount: inNumberFrames)
            
            return result
        }
        
        // æ³¨å†Œå›è°ƒ
        registerRenderCallback(renderCallback, refCon: Unmanaged.passUnretained(self).toOpaque())
    }
    
    func processAudioFrame(_ ioActionFlags: UnsafeMutablePointer<AudioUnitRenderActionFlags>?,
                          _ inTimeStamp: UnsafePointer<AudioTimeStamp>?,
                          _ inBusNumber: UInt32,
                          _ inNumberFrames: UInt32,
                          _ ioData: UnsafeMutablePointer<AudioBufferList>?) -> OSStatus {
        
        // æ€§èƒ½å…³é”®è·¯å¾„æ ‡è®°
        os_signpost(.begin, log: audioLog, name: "Frame_Processing", 
                   "Frames: %{public}d", inNumberFrames)
        
        defer {
            os_signpost(.end, log: audioLog, name: "Frame_Processing")
        }
        
        // æ£€æŸ¥æ€§èƒ½çº¦æŸ
        checkPerformanceConstraints()
        
        // å®é™…éŸ³é¢‘å¤„ç†
        return performAudioProcessing(ioData, frameCount: inNumberFrames)
    }
    
    private func checkPerformanceConstraints() {
        let currentTime = mach_absolute_time()
        
        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡å®æ—¶çº¦æŸ
        if let lastFrameTime = renderingMetrics.lastFrameTime {
            let interval = currentTime - lastFrameTime
            let intervalNanos = AudioConvertHostTimeToNanos(interval)
            
            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é¢„æœŸé—´éš”ï¼ˆé€šå¸¸åŸºäºé‡‡æ ·ç‡ï¼‰
            let expectedInterval: UInt64 = 10_416_667 // ~10.4ms for 1024 frames at 48kHz
            
            if intervalNanos > expectedInterval * 2 {
                os_log(.error, log: audioLog, "Performance constraint violation: %{public}llu ns", intervalNanos)
                renderingMetrics.constraintViolations += 1
            }
        }
        
        renderingMetrics.lastFrameTime = currentTime
    }
    
    private func collectRenderingMetrics(duration: UInt64, frameCount: UInt32) {
        let durationNanos = AudioConvertHostTimeToNanos(duration)
        
        renderingMetrics.totalFramesProcessed += frameCount
        renderingMetrics.totalProcessingTime += durationNanos
        renderingMetrics.frameCount += 1
        
        // æ›´æ–°æœ€å¤§/æœ€å°å¤„ç†æ—¶é—´
        if durationNanos > renderingMetrics.maxProcessingTime {
            renderingMetrics.maxProcessingTime = durationNanos
        }
        
        if durationNanos < renderingMetrics.minProcessingTime || renderingMetrics.minProcessingTime == 0 {
            renderingMetrics.minProcessingTime = durationNanos
        }
        
        // æ£€æŸ¥å¤„ç†æ—¶é—´æ˜¯å¦è¶…è¿‡é˜ˆå€¼
        let thresholdNanos: UInt64 = 5_000_000 // 5ms
        if durationNanos > thresholdNanos {
            renderingMetrics.timeoutCount += 1
            os_log(.error, log: audioLog, "Audio processing timeout: %{public}llu ns", durationNanos)
        }
        
        // å®šæœŸè¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        if renderingMetrics.frameCount % 1000 == 0 {
            outputPerformanceStatistics()
        }
    }
    
    private func outputPerformanceStatistics() {
        let avgProcessingTime = renderingMetrics.totalProcessingTime / UInt64(renderingMetrics.frameCount)
        
        os_log(.info, log: audioLog, """
            Audio Performance Statistics:
            Frames Processed: %{public}d
            Avg Processing Time: %{public}llu ns
            Max Processing Time: %{public}llu ns
            Min Processing Time: %{public}llu ns
            Timeouts: %{public}d
            Constraint Violations: %{public}d
            """,
            renderingMetrics.frameCount,
            avgProcessingTime,
            renderingMetrics.maxProcessingTime,
            renderingMetrics.minProcessingTime,
            renderingMetrics.timeoutCount,
            renderingMetrics.constraintViolations
        )
    }
    
    // è™šæ‹Ÿæ–¹æ³•ï¼Œå®é™…å®ç°ä¸­éœ€è¦å…·ä½“çš„éŸ³é¢‘å¤„ç†é€»è¾‘
    private func performAudioProcessing(_ ioData: UnsafeMutablePointer<AudioBufferList>?, frameCount: UInt32) -> OSStatus {
        return noErr
    }
    
    private func registerRenderCallback(_ callback: @escaping AURenderCallback, refCon: UnsafeMutableRawPointer) {
        // æ³¨å†ŒéŸ³é¢‘æ¸²æŸ“å›è°ƒçš„å®ç°
    }
}

// æ¸²æŸ“æ€§èƒ½æŒ‡æ ‡
struct RenderingMetrics {
    var totalFramesProcessed: UInt32 = 0
    var totalProcessingTime: UInt64 = 0
    var frameCount: Int = 0
    var maxProcessingTime: UInt64 = 0
    var minProcessingTime: UInt64 = 0
    var timeoutCount: Int = 0
    var constraintViolations: Int = 0
    var lastFrameTime: UInt64?
}

// å†…å­˜æ€§èƒ½æŒ‡æ ‡
struct MemoryMetrics {
    var peakMemoryUsage: Int = 0
    var currentMemoryUsage: Int = 0
    var allocationCount: Int = 0
    var deallocationCount: Int = 0
    var leakCount: Int = 0
}

// CPUæ€§èƒ½æŒ‡æ ‡
struct CPUMetrics {
    var averageCPUUsage: Float = 0.0
    var peakCPUUsage: Float = 0.0
    var audioThreadCPUUsage: Float = 0.0
    var thermalState: ProcessInfo.ThermalState = .nominal
}
```

### 2. Time Profiler éŸ³é¢‘çº¿ç¨‹åˆ†æ

```swift
// éŸ³é¢‘çº¿ç¨‹æ€§èƒ½åˆ†æå™¨
class AudioThreadProfiler {
    private let profilingQueue = DispatchQueue(label: "audio.profiling", qos: .background)
    private var isProfilingActive = false
    
    // çº¿ç¨‹ç›‘æ§
    private var threadMetrics: [pthread_t: ThreadMetrics] = [:]
    private let metricsLock = NSLock()
    
    func startProfiling() {
        guard !isProfilingActive else { return }
        isProfilingActive = true
        
        profilingQueue.async {
            self.profilingLoop()
        }
    }
    
    private func profilingLoop() {
        while isProfilingActive {
            collectThreadMetrics()
            analyzeThreadPerformance()
            Thread.sleep(forTimeInterval: 0.1)
        }
    }
    
    private func collectThreadMetrics() {
        var threadList: thread_array_t?
        var threadCount: mach_msg_type_number_t = 0
        
        let kr = task_threads(mach_task_self(), &threadList, &threadCount)
        
        guard kr == KERN_SUCCESS, let threads = threadList else { return }
        
        defer {
            vm_deallocate(mach_task_self(), vm_address_t(bitPattern: threads), vm_size_t(threadCount * UInt32(MemoryLayout<thread_t>.size)))
        }
        
        for i in 0..<Int(threadCount) {
            let thread = threads[i]
            collectSingleThreadMetrics(thread)
        }
    }
    
    private func collectSingleThreadMetrics(_ thread: thread_t) {
        var threadInfo = thread_basic_info()
        var threadInfoCount = mach_msg_type_number_t(THREAD_BASIC_INFO_COUNT)
        
        let kr = withUnsafeMutablePointer(to: &threadInfo) {
            $0.withMemoryRebound(to: integer_t.self, capacity: Int(threadInfoCount)) {
                thread_info(thread, thread_flavor_t(THREAD_BASIC_INFO), $0, &threadInfoCount)
            }
        }
        
        guard kr == KERN_SUCCESS else { return }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯éŸ³é¢‘çº¿ç¨‹
        if isAudioThread(thread) {
            let metrics = ThreadMetrics(
                cpuUsage: calculateCPUUsage(threadInfo),
                userTime: Double(threadInfo.user_time.seconds) + Double(threadInfo.user_time.microseconds) / 1_000_000,
                systemTime: Double(threadInfo.system_time.seconds) + Double(threadInfo.system_time.microseconds) / 1_000_000,
                state: ThreadState(rawValue: threadInfo.run_state) ?? .unknown
            )
            
            metricsLock.lock()
            threadMetrics[pthread_from_mach_thread_np(thread)] = metrics
            metricsLock.unlock()
        }
    }
    
    private func isAudioThread(_ thread: thread_t) -> Bool {
        // æ£€æŸ¥çº¿ç¨‹åç§°
        var name = [CChar](repeating: 0, count: 256)
        pthread_getname_np(pthread_from_mach_thread_np(thread), &name, 256)
        let threadName = String(cString: name)
        
        return threadName.contains("audio") || threadName.contains("Audio") || threadName.contains("com.apple.audio")
    }
    
    private func calculateCPUUsage(_ threadInfo: thread_basic_info) -> Float {
        let totalTime = threadInfo.user_time.microseconds + threadInfo.system_time.microseconds
        return Float(totalTime) / 1_000_000 // è½¬æ¢ä¸ºç§’
    }
    
    private func analyzeThreadPerformance() {
        metricsLock.lock()
        defer { metricsLock.unlock() }
        
        for (thread, metrics) in threadMetrics {
            if metrics.cpuUsage > 0.8 {
                logHighCPUUsage(thread: thread, metrics: metrics)
            }
            
            if metrics.state == .waiting {
                logThreadBlocking(thread: thread, metrics: metrics)
            }
        }
    }
    
    private func logHighCPUUsage(thread: pthread_t, metrics: ThreadMetrics) {
        let threadId = UInt64(bitPattern: thread)
        print("é«˜CPUä½¿ç”¨ç‡è­¦å‘Š - çº¿ç¨‹ID: \(threadId), CPUä½¿ç”¨ç‡: \(metrics.cpuUsage)")
    }
    
    private func logThreadBlocking(thread: pthread_t, metrics: ThreadMetrics) {
        let threadId = UInt64(bitPattern: thread)
        print("çº¿ç¨‹é˜»å¡è­¦å‘Š - çº¿ç¨‹ID: \(threadId), çŠ¶æ€: \(metrics.state)")
    }
}

// çº¿ç¨‹æ€§èƒ½æŒ‡æ ‡
struct ThreadMetrics {
    let cpuUsage: Float
    let userTime: Double
    let systemTime: Double
    let state: ThreadState
}

// çº¿ç¨‹çŠ¶æ€
enum ThreadState: Int32 {
    case running = 1
    case stopped = 2
    case waiting = 3
    case uninterruptible = 4
    case halted = 5
    case unknown = 0
}
```

## å†…å­˜æ³„æ¼æ£€æµ‹ä¸åˆ†æ

### 1. éŸ³é¢‘å†…å­˜æ³„æ¼æ£€æµ‹å™¨

```swift
// éŸ³é¢‘å†…å­˜æ³„æ¼æ£€æµ‹å™¨
class AudioMemoryLeakDetector {
    private var allocatedBuffers: Set<AudioBufferTracker> = []
    private var allocatedObjects: [ObjectIdentifier: AudioObjectTracker] = [:]
    private let trackingLock = NSRecursiveLock()
    
    // å†…å­˜åˆ†é…è·Ÿè¸ª
    func trackBufferAllocation(_ buffer: UnsafeMutableRawPointer, size: Int, location: String = #file + ":\(#line)") {
        trackingLock.lock()
        defer { trackingLock.unlock() }
        
        let tracker = AudioBufferTracker(
            pointer: buffer,
            size: size,
            allocatedAt: Date(),
            location: location,
            stackTrace: Thread.callStackSymbols
        )
        
        allocatedBuffers.insert(tracker)
    }
    
    func trackBufferDeallocation(_ buffer: UnsafeMutableRawPointer) {
        trackingLock.lock()
        defer { trackingLock.unlock() }
        
        if let tracker = allocatedBuffers.first(where: { $0.pointer == buffer }) {
            allocatedBuffers.remove(tracker)
        } else {
            print("è­¦å‘Šï¼šå°è¯•é‡Šæ”¾æœªè·Ÿè¸ªçš„ç¼“å†²åŒº \(buffer)")
        }
    }
    
    func trackObjectAllocation<T: AnyObject>(_ object: T, location: String = #file + ":\(#line)") {
        trackingLock.lock()
        defer { trackingLock.unlock() }
        
        let objectId = ObjectIdentifier(object)
        let tracker = AudioObjectTracker(
            objectId: objectId,
            objectType: String(describing: type(of: object)),
            allocatedAt: Date(),
            location: location,
            stackTrace: Thread.callStackSymbols
        )
        
        allocatedObjects[objectId] = tracker
    }
    
    func trackObjectDeallocation<T: AnyObject>(_ object: T) {
        trackingLock.lock()
        defer { trackingLock.unlock() }
        
        let objectId = ObjectIdentifier(object)
        allocatedObjects.removeValue(forKey: objectId)
    }
    
    // æ³„æ¼æ£€æµ‹
    func detectLeaks() -> AudioMemoryLeakReport {
        trackingLock.lock()
        defer { trackingLock.unlock() }
        
        let now = Date()
        let leakThreshold: TimeInterval = 300 // 5åˆ†é’Ÿ
        
        let bufferLeaks = allocatedBuffers.filter { tracker in
            now.timeIntervalSince(tracker.allocatedAt) > leakThreshold
        }
        
        let objectLeaks = allocatedObjects.values.filter { tracker in
            now.timeIntervalSince(tracker.allocatedAt) > leakThreshold
        }
        
        return AudioMemoryLeakReport(
            bufferLeaks: Array(bufferLeaks),
            objectLeaks: Array(objectLeaks),
            timestamp: now
        )
    }
    
    // å†…å­˜ä½¿ç”¨åˆ†æ
    func analyzeMemoryUsage() -> AudioMemoryUsageReport {
        trackingLock.lock()
        defer { trackingLock.unlock() }
        
        let totalBufferMemory = allocatedBuffers.reduce(0) { $0 + $1.size }
        let bufferCount = allocatedBuffers.count
        let objectCount = allocatedObjects.count
        
        // æŒ‰ç±»å‹åˆ†ç»„å¯¹è±¡
        let objectsByType = Dictionary(grouping: allocatedObjects.values) { $0.objectType }
        
        return AudioMemoryUsageReport(
            totalBufferMemory: totalBufferMemory,
            bufferCount: bufferCount,
            objectCount: objectCount,
            objectsByType: objectsByType.mapValues { $0.count },
            timestamp: Date()
        )
    }
}

// ç¼“å†²åŒºè·Ÿè¸ªå™¨
struct AudioBufferTracker: Hashable {
    let pointer: UnsafeMutableRawPointer
    let size: Int
    let allocatedAt: Date
    let location: String
    let stackTrace: [String]
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(ObjectIdentifier(pointer.assumingMemoryBound(to: Void.self)))
    }
    
    static func == (lhs: AudioBufferTracker, rhs: AudioBufferTracker) -> Bool {
        return lhs.pointer == rhs.pointer
    }
}

// å¯¹è±¡è·Ÿè¸ªå™¨
struct AudioObjectTracker {
    let objectId: ObjectIdentifier
    let objectType: String
    let allocatedAt: Date
    let location: String
    let stackTrace: [String]
}

// å†…å­˜æ³„æ¼æŠ¥å‘Š
struct AudioMemoryLeakReport {
    let bufferLeaks: [AudioBufferTracker]
    let objectLeaks: [AudioObjectTracker]
    let timestamp: Date
    
    var hasLeaks: Bool {
        return !bufferLeaks.isEmpty || !objectLeaks.isEmpty
    }
    
    func generateReport() -> String {
        var report = "=== éŸ³é¢‘å†…å­˜æ³„æ¼æŠ¥å‘Š ===\n"
        report += "ç”Ÿæˆæ—¶é—´: \(timestamp)\n\n"
        
        if bufferLeaks.isEmpty && objectLeaks.isEmpty {
            report += "âœ… æœªæ£€æµ‹åˆ°å†…å­˜æ³„æ¼\n"
        } else {
            if !bufferLeaks.isEmpty {
                report += "ğŸš¨ ç¼“å†²åŒºæ³„æ¼ (\(bufferLeaks.count) ä¸ª):\n"
                for leak in bufferLeaks {
                    report += "  - å¤§å°: \(leak.size) bytes, ä½ç½®: \(leak.location)\n"
                    report += "    åˆ†é…æ—¶é—´: \(leak.allocatedAt)\n"
                }
                report += "\n"
            }
            
            if !objectLeaks.isEmpty {
                report += "ğŸš¨ å¯¹è±¡æ³„æ¼ (\(objectLeaks.count) ä¸ª):\n"
                for leak in objectLeaks {
                    report += "  - ç±»å‹: \(leak.objectType), ä½ç½®: \(leak.location)\n"
                    report += "    åˆ†é…æ—¶é—´: \(leak.allocatedAt)\n"
                }
            }
        }
        
        return report
    }
}

// å†…å­˜ä½¿ç”¨æŠ¥å‘Š
struct AudioMemoryUsageReport {
    let totalBufferMemory: Int
    let bufferCount: Int
    let objectCount: Int
    let objectsByType: [String: Int]
    let timestamp: Date
    
    func generateReport() -> String {
        var report = "=== éŸ³é¢‘å†…å­˜ä½¿ç”¨æŠ¥å‘Š ===\n"
        report += "ç”Ÿæˆæ—¶é—´: \(timestamp)\n\n"
        
        report += "ç¼“å†²åŒºå†…å­˜:\n"
        report += "  æ€»å¤§å°: \(formatBytes(totalBufferMemory))\n"
        report += "  ç¼“å†²åŒºæ•°é‡: \(bufferCount)\n"
        report += "  å¹³å‡å¤§å°: \(formatBytes(totalBufferMemory / max(bufferCount, 1)))\n\n"
        
        report += "å¯¹è±¡ç»Ÿè®¡:\n"
        report += "  æ€»å¯¹è±¡æ•°: \(objectCount)\n"
        
        if !objectsByType.isEmpty {
            report += "  æŒ‰ç±»å‹åˆ†å¸ƒ:\n"
            for (type, count) in objectsByType.sorted(by: { $0.value > $1.value }) {
                report += "    \(type): \(count)\n"
            }
        }
        
        return report
    }
    
    private func formatBytes(_ bytes: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useKB, .useMB, .useGB]
        formatter.countStyle = .memory
        return formatter.string(fromByteCount: Int64(bytes))
    }
}
```

## Audio Unit éªŒè¯ä¸æµ‹è¯•

### 1. Audio Unit è‡ªåŠ¨åŒ–éªŒè¯

```swift
// Audio Unit éªŒè¯å™¨
class AudioUnitValidator {
    private let testSuite = AudioUnitTestSuite()
    private let performanceTester = AudioUnitPerformanceTester()
    private let compatibilityTester = AudioUnitCompatibilityTester()
    
    func validateAudioUnit(_ audioUnit: AudioUnit) -> AudioUnitValidationResult {
        var results: [AudioUnitTestResult] = []
        
        // åŸºç¡€åŠŸèƒ½æµ‹è¯•
        results.append(testBasicFunctionality(audioUnit))
        
        // æ€§èƒ½æµ‹è¯•
        results.append(testPerformance(audioUnit))
        
        // å…¼å®¹æ€§æµ‹è¯•
        results.append(testCompatibility(audioUnit))
        
        // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
        results.append(testBoundaryConditions(audioUnit))
        
        // å†…å­˜å®‰å…¨æµ‹è¯•
        results.append(testMemorySafety(audioUnit))
        
        return AudioUnitValidationResult(results: results)
    }
    
    private func testBasicFunctionality(_ audioUnit: AudioUnit) -> AudioUnitTestResult {
        var errors: [String] = []
        
        // æµ‹è¯•åˆå§‹åŒ–
        if !testInitialization(audioUnit) {
            errors.append("AudioUnit åˆå§‹åŒ–å¤±è´¥")
        }
        
        // æµ‹è¯•å‚æ•°è®¾ç½®
        if !testParameterSetting(audioUnit) {
            errors.append("å‚æ•°è®¾ç½®å¤±è´¥")
        }
        
        // æµ‹è¯•éŸ³é¢‘æ¸²æŸ“
        if !testAudioRendering(audioUnit) {
            errors.append("éŸ³é¢‘æ¸²æŸ“å¤±è´¥")
        }
        
        // æµ‹è¯•æ ¼å¼æ”¯æŒ
        if !testFormatSupport(audioUnit) {
            errors.append("éŸ³é¢‘æ ¼å¼æ”¯æŒä¸å®Œæ•´")
        }
        
        return AudioUnitTestResult(
            testName: "åŸºç¡€åŠŸèƒ½æµ‹è¯•",
            passed: errors.isEmpty,
            errors: errors
        )
    }
    
    private func testPerformance(_ audioUnit: AudioUnit) -> AudioUnitTestResult {
        let performanceMetrics = performanceTester.measurePerformance(audioUnit)
        var errors: [String] = []
        
        // æ£€æŸ¥CPUä½¿ç”¨ç‡
        if performanceMetrics.maxCPUUsage > 0.5 {
            errors.append("CPUä½¿ç”¨ç‡è¿‡é«˜: \(performanceMetrics.maxCPUUsage)")
        }
        
        // æ£€æŸ¥å†…å­˜ä½¿ç”¨
        if performanceMetrics.memoryUsage > 50_000_000 { // 50MB
            errors.append("å†…å­˜ä½¿ç”¨è¿‡é«˜: \(performanceMetrics.memoryUsage) bytes")
        }
        
        // æ£€æŸ¥å»¶è¿Ÿ
        if performanceMetrics.processingLatency > 0.010 { // 10ms
            errors.append("å¤„ç†å»¶è¿Ÿè¿‡é«˜: \(performanceMetrics.processingLatency)s")
        }
        
        return AudioUnitTestResult(
            testName: "æ€§èƒ½æµ‹è¯•",
            passed: errors.isEmpty,
            errors: errors,
            metrics: performanceMetrics
        )
    }
    
    private func testCompatibility(_ audioUnit: AudioUnit) -> AudioUnitTestResult {
        let compatibilityResults = compatibilityTester.testCompatibility(audioUnit)
        
        return AudioUnitTestResult(
            testName: "å…¼å®¹æ€§æµ‹è¯•",
            passed: compatibilityResults.allTestsPassed,
            errors: compatibilityResults.errors
        )
    }
    
    private func testBoundaryConditions(_ audioUnit: AudioUnit) -> AudioUnitTestResult {
        var errors: [String] = []
        
        // æµ‹è¯•æé™å‚æ•°å€¼
        if !testExtremeParameterValues(audioUnit) {
            errors.append("æé™å‚æ•°å€¼å¤„ç†å¤±è´¥")
        }
        
        // æµ‹è¯•é›¶å¤§å°ç¼“å†²åŒº
        if !testZeroSizeBuffer(audioUnit) {
            errors.append("é›¶å¤§å°ç¼“å†²åŒºå¤„ç†å¤±è´¥")
        }
        
        // æµ‹è¯•æ— æ•ˆè¾“å…¥
        if !testInvalidInput(audioUnit) {
            errors.append("æ— æ•ˆè¾“å…¥å¤„ç†å¤±è´¥")
        }
        
        return AudioUnitTestResult(
            testName: "è¾¹ç•Œæ¡ä»¶æµ‹è¯•",
            passed: errors.isEmpty,
            errors: errors
        )
    }
    
    private func testMemorySafety(_ audioUnit: AudioUnit) -> AudioUnitTestResult {
        let memoryTester = MemorySafetyTester()
        let results = memoryTester.testAudioUnit(audioUnit)
        
        return AudioUnitTestResult(
            testName: "å†…å­˜å®‰å…¨æµ‹è¯•",
            passed: results.noViolations,
            errors: results.violations
        )
    }
    
    // å…·ä½“æµ‹è¯•æ–¹æ³•çš„å®ç°
    private func testInitialization(_ audioUnit: AudioUnit) -> Bool {
        // æµ‹è¯•AudioUnitåˆå§‹åŒ–
        var result = AudioUnitInitialize(audioUnit)
        return result == noErr
    }
    
    private func testParameterSetting(_ audioUnit: AudioUnit) -> Bool {
        // æµ‹è¯•å‚æ•°è®¾ç½®
        let result = AudioUnitSetParameter(audioUnit, 0, kAudioUnitScope_Global, 0, 0.5, 0)
        return result == noErr
    }
    
    private func testAudioRendering(_ audioUnit: AudioUnit) -> Bool {
        // åˆ›å»ºæµ‹è¯•ç¼“å†²åŒº
        let frameCount: UInt32 = 512
        let channelCount: UInt32 = 2
        let bufferSize = frameCount * channelCount * UInt32(MemoryLayout<Float>.size)
        
        let audioBuffer = AudioBuffer(
            mNumberChannels: channelCount,
            mDataByteSize: bufferSize,
            mData: malloc(Int(bufferSize))
        )
        
        defer { free(audioBuffer.mData) }
        
        var bufferList = AudioBufferList(
            mNumberBuffers: 1,
            mBuffers: audioBuffer
        )
        
        var actionFlags: AudioUnitRenderActionFlags = []
        var timeStamp = AudioTimeStamp()
        timeStamp.mFlags = AudioTimeStampFlags.sampleTimeValid
        timeStamp.mSampleTime = 0
        
        let result = AudioUnitRender(audioUnit, &actionFlags, &timeStamp, 0, frameCount, &bufferList)
        return result == noErr
    }
    
    private func testFormatSupport(_ audioUnit: AudioUnit) -> Bool {
        // æµ‹è¯•å¸¸è§éŸ³é¢‘æ ¼å¼æ”¯æŒ
        let formats = [
            createFormat(sampleRate: 44100, channels: 2),
            createFormat(sampleRate: 48000, channels: 2),
            createFormat(sampleRate: 44100, channels: 1),
            createFormat(sampleRate: 96000, channels: 2)
        ]
        
        for format in formats {
            var formatSize = UInt32(MemoryLayout<AudioStreamBasicDescription>.size)
            let result = AudioUnitSetProperty(audioUnit,
                                            kAudioUnitProperty_StreamFormat,
                                            kAudioUnitScope_Input,
                                            0,
                                            &format,
                                            formatSize)
            if result != noErr {
                return false
            }
        }
        
        return true
    }
    
    private func createFormat(sampleRate: Double, channels: UInt32) -> AudioStreamBasicDescription {
        return AudioStreamBasicDescription(
            mSampleRate: sampleRate,
            mFormatID: kAudioFormatLinearPCM,
            mFormatFlags: kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked,
            mBytesPerPacket: channels * 4,
            mFramesPerPacket: 1,
            mBytesPerFrame: channels * 4,
            mChannelsPerFrame: channels,
            mBitsPerChannel: 32,
            mReserved: 0
        )
    }
    
    private func testExtremeParameterValues(_ audioUnit: AudioUnit) -> Bool {
        let testValues: [AudioUnitParameterValue] = [0, 1, -1, Float.greatestFiniteMagnitude, -Float.greatestFiniteMagnitude]
        
        for value in testValues {
            let result = AudioUnitSetParameter(audioUnit, 0, kAudioUnitScope_Global, 0, value, 0)
            if result != noErr && result != kAudioUnitErr_InvalidParameter {
                return false
            }
        }
        
        return true
    }
    
    private func testZeroSizeBuffer(_ audioUnit: AudioUnit) -> Bool {
        var bufferList = AudioBufferList(
            mNumberBuffers: 1,
            mBuffers: AudioBuffer(mNumberChannels: 2, mDataByteSize: 0, mData: nil)
        )
        
        var actionFlags: AudioUnitRenderActionFlags = []
        var timeStamp = AudioTimeStamp()
        
        let result = AudioUnitRender(audioUnit, &actionFlags, &timeStamp, 0, 0, &bufferList)
        return result == noErr || result == kAudioUnitErr_InvalidParameter
    }
    
    private func testInvalidInput(_ audioUnit: AudioUnit) -> Bool {
        // æµ‹è¯•ä¼ å…¥æ— æ•ˆæŒ‡é’ˆç­‰
        let result = AudioUnitRender(audioUnit, nil, nil, 0, 512, nil)
        return result != noErr // åº”è¯¥è¿”å›é”™è¯¯
    }
}

// Audio Unit æµ‹è¯•ç»“æœ
struct AudioUnitTestResult {
    let testName: String
    let passed: Bool
    let errors: [String]
    let metrics: AudioUnitPerformanceMetrics?
    
    init(testName: String, passed: Bool, errors: [String], metrics: AudioUnitPerformanceMetrics? = nil) {
        self.testName = testName
        self.passed = passed
        self.errors = errors
        self.metrics = metrics
    }
}

// éªŒè¯ç»“æœ
struct AudioUnitValidationResult {
    let results: [AudioUnitTestResult]
    
    var allTestsPassed: Bool {
        return results.allSatisfy { $0.passed }
    }
    
    var failedTests: [AudioUnitTestResult] {
        return results.filter { !$0.passed }
    }
    
    func generateReport() -> String {
        var report = "=== Audio Unit éªŒè¯æŠ¥å‘Š ===\n\n"
        
        let passedCount = results.filter { $0.passed }.count
        let totalCount = results.count
        
        report += "æ€»ä½“ç»“æœ: \(passedCount)/\(totalCount) æµ‹è¯•é€šè¿‡\n"
        report += "éªŒè¯çŠ¶æ€: \(allTestsPassed ? "âœ… é€šè¿‡" : "âŒ å¤±è´¥")\n\n"
        
        for result in results {
            report += "ã€\(result.testName)ã€‘: \(result.passed ? "âœ…" : "âŒ")\n"
            
            if !result.errors.isEmpty {
                for error in result.errors {
                    report += "  âŒ \(error)\n"
                }
            }
            
            if let metrics = result.metrics {
                report += "  ğŸ“Š æ€§èƒ½æŒ‡æ ‡:\n"
                report += "     CPUä½¿ç”¨ç‡: \(String(format: "%.1f%%", metrics.maxCPUUsage * 100))\n"
                report += "     å†…å­˜ä½¿ç”¨: \(formatBytes(metrics.memoryUsage))\n"
                report += "     å¤„ç†å»¶è¿Ÿ: \(String(format: "%.2f ms", metrics.processingLatency * 1000))\n"
            }
            
            report += "\n"
        }
        
        return report
    }
    
    private func formatBytes(_ bytes: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useKB, .useMB]
        formatter.countStyle = .memory
        return formatter.string(fromByteCount: Int64(bytes))
    }
}

// æ€§èƒ½æŒ‡æ ‡
struct AudioUnitPerformanceMetrics {
    let maxCPUUsage: Float
    let memoryUsage: Int
    let processingLatency: TimeInterval
}

// å…¼å®¹æ€§æµ‹è¯•ç»“æœ
struct AudioUnitCompatibilityResult {
    let allTestsPassed: Bool
    let errors: [String]
}

// å†…å­˜å®‰å…¨æµ‹è¯•ç»“æœ
struct MemorySafetyTestResult {
    let noViolations: Bool
    let violations: [String]
}

// æ€§èƒ½æµ‹è¯•å™¨
class AudioUnitPerformanceTester {
    func measurePerformance(_ audioUnit: AudioUnit) -> AudioUnitPerformanceMetrics {
        // å®ç°æ€§èƒ½æµ‹é‡é€»è¾‘
        return AudioUnitPerformanceMetrics(
            maxCPUUsage: 0.3,
            memoryUsage: 1024 * 1024,
            processingLatency: 0.005
        )
    }
}

// å…¼å®¹æ€§æµ‹è¯•å™¨
class AudioUnitCompatibilityTester {
    func testCompatibility(_ audioUnit: AudioUnit) -> AudioUnitCompatibilityResult {
        // å®ç°å…¼å®¹æ€§æµ‹è¯•é€»è¾‘
        return AudioUnitCompatibilityResult(
            allTestsPassed: true,
            errors: []
        )
    }
}

// å†…å­˜å®‰å…¨æµ‹è¯•å™¨
class MemorySafetyTester {
    func testAudioUnit(_ audioUnit: AudioUnit) -> MemorySafetyTestResult {
        // å®ç°å†…å­˜å®‰å…¨æµ‹è¯•é€»è¾‘
        return MemorySafetyTestResult(
            noViolations: true,
            violations: []
        )
    }
}

// æµ‹è¯•å¥—ä»¶
class AudioUnitTestSuite {
    // æµ‹è¯•å¥—ä»¶å®ç°
}
```

## æ€»ç»“

éŸ³é¢‘è°ƒè¯•ä¸æ€§èƒ½åˆ†ææ˜¯ç¡®ä¿éŸ³é¢‘åº”ç”¨è´¨é‡çš„å…³é”®æŠ€æœ¯ã€‚æœ¬æ–‡æ¡£æä¾›äº†ï¼š

1. **Instrumentsé›†æˆ**ï¼šæ·±åº¦åˆ©ç”¨Appleå®˜æ–¹æ€§èƒ½åˆ†æå·¥å…·
2. **å®æ—¶ç›‘æ§**ï¼šæŒç»­ç›‘æ§éŸ³é¢‘æ€§èƒ½æŒ‡æ ‡
3. **å†…å­˜æ³„æ¼æ£€æµ‹**ï¼šä¸“é—¨é’ˆå¯¹éŸ³é¢‘åº”ç”¨çš„å†…å­˜ç®¡ç†
4. **è‡ªåŠ¨åŒ–éªŒè¯**ï¼šAudio Unitçš„å…¨é¢æµ‹è¯•æ¡†æ¶

é€šè¿‡è¿™äº›å·¥å…·å’ŒæŠ€æœ¯ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºæ›´åŠ ç¨³å®šã€é«˜æ€§èƒ½çš„éŸ³é¢‘åº”ç”¨ã€‚ 